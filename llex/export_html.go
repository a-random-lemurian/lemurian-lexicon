package llex

import (
	"bytes"
	"html/template"
	"sort"
	"strings"
	"time"
)

var CSS = `
		.dictionary ol {
      margin: 0px;
    }
		a {
			color: #acc0fb;
		}
		body {
			background-color: #000;
			color: #fff;
			max-width: 600px;
			margin: auto;
		}
		.entry {
			break-inside: avoid;
			margin-bottom: 8px;
			padding-bottom: 8px;
		}
		.auxilliary p {
			font-size: 85%;
			margin: 0.1%;
		}
		.navbar .letter {
			padding: 5px;
			font-size: 110%;
		}`

// TODO: Do not hardcode "{{.LanguageName}} - English".

var HtmlTemplate = `
<!DOCTYPE html>
<html>
<head>
    <meta charset='utf-8'>
    <meta http-equiv='X-UA-Compatible' content='IE=edge'>
    <title>{{.LanguageName}} Dictionary</title>
    <meta name='viewport' content='width=device-width, initial-scale=1'>
		<meta name="generator" content="lemurian-lexicon-manager">
		{{if .UseEmbeddedCSS}}
    <style>{{.CSS}}</style>
		{{else}}
		<link rel="stylesheet" href="{{.CSSFile}}">
		{{end}}
</head>
<body>
		<div class="header">
		{{if .Multipage}}<a href="./index.html">Return to index</a> or <a href="/">root page</a>.{{else}}{{end}}
    <h1><span class="language-name">{{.LanguageName}}</span></h1>
		{{if .ShowNavbar}}{{.NavbarHTML}}{{else}}{{end}}
    </div>
		<hr>
	{{if .AuthorsNote}}<div class="authors-note">{{.AuthorsNote}}</div>{{end}}
	{{if .HTMLEntries}}
    <div class="dictionary">
	{{range .HTMLEntries}}
	{{.}}
	{{end}}
	</div>
	{{end}}
	{{if .IndexPage}}
	<p>Welcome to the lexicon for {{.LanguageName}}. This is a {{.LanguageName}} - English dictionary,
	not the other way around. To get started, click on any letter of the alphabet in the navbar.</p>
	<p>To make searching easier, feel free to access a <a href="./all-words.html">single-page</a> version.</p>
	{{end}}
    <hr>
	<p><b>Copyright</b>: {{.Copyright}}</p>
	<p>Generated by the
	   <a href="https://github.com/a-random-lemurian/lemurian-lexicon">Lemurian Lexicon Manager</a>
	   at <span class="timestamp">{{.Timestamp}}</span>.
	   Generation time <span class="generation-time">{{.GenerationTime}}</span>.
	   Contains <span class="num-words">{{.NumWords}}</span> words.</p>
</body>
</html>
`

var WordTemplate = `<div class="entry">
<b><span class="headword">{{.Word}}</span></b> <i><span class="part-of-speech">{{.POS}}</span></i> <br>
<ol class="definitions">
{{range .Definitions}}<li class="definition">{{.Text}}</li>{{end}}
</ol><div class="auxilliary">{{if .Etymology}}
<p>Etymology: <span class="etymology">{{.Etymology}}</span></p>{{else}}{{end}}
{{if .BorrowedWord}}<p>From: <span class="borrowed-from">{{.BorrowedWord}}</span>{{else}}{{end}}</div>
</div>`

type htmlParameters struct {
	LanguageName   string
	HTMLEntries    []template.HTML
	Timestamp      time.Time
	NumWords       int
	GenerationTime string
	Copyright      template.HTML
	AuthorsNote    template.HTML
	UseEmbeddedCSS bool
	CSS            template.CSS
	CSSFile        template.HTML
	Multipage      bool
	ShowNavbar     bool
	NavbarHTML     template.HTML
	IndexPage      bool
}

func NewStaticExportParams(dict *Dictionary) *StaticExportParams {
	params := &StaticExportParams{
		Dictionary: dict,
	}
	params.Copyright = "No copyright information provided."
	params.AuthorsNote = ""
	return params
}

func (e *Entry) GenerateHTML() (string, error) {
	t, err := template.New("html").Parse(WordTemplate)
	if err != nil {
		return "", err
	}

	var html bytes.Buffer

	err = t.Execute(&html, e)

	if err != nil {
		return "", err
	}

	return html.String(), nil
}

func batchGenerateEntryHTML(entries []*Entry) ([]template.HTML, error) {
	var entriesHTML []template.HTML
	for _, entry := range entries {
		entryHTML, err := entry.GenerateHTML()
		if err != nil {
			return nil, err
		}
		entriesHTML = append(entriesHTML, template.HTML(entryHTML))
	}
	return entriesHTML, nil
}

func sortEntries(entries []*Entry) []*Entry {
	sort.Slice(entries, func(i, j int) bool {
		return strings.ToLower(entries[i].Word) < strings.ToLower(entries[j].Word)
	})
	return entries
}

// Export a Dictionary to a single HTML file.
func ExportSinglePageHTML(params *StaticExportParams) (string, error) {
	startTime := time.Now()
	dict := params.Dictionary

	sortedEntries := sortEntries(dict.Entries)
	sortedEntriesHTML, err := batchGenerateEntryHTML(sortedEntries)
	if err != nil {
		return "", err
	}

	endTime := time.Now()

	htmlParams := htmlParameters{
		LanguageName:   dict.LanguageName,
		HTMLEntries:    sortedEntriesHTML,
		Timestamp:      endTime,
		GenerationTime: endTime.Sub(startTime).String(),
		NumWords:       len(dict.Entries),
		Copyright:      template.HTML(params.Copyright),
		AuthorsNote:    template.HTML(params.AuthorsNote),
		Multipage:      params.Multipage,
		ShowNavbar:     params.ShowNavbar,
		NavbarHTML:     params.NavbarHTML,
	}

	if params.CSSFile != "" {
		htmlParams.CSSFile = template.HTML(params.CSSFile)
		htmlParams.UseEmbeddedCSS = false
	}

	return executeHTMLTemplate(&htmlParams)
}

// Execute the template to create the necessary HTML with parameters already fed in.
func executeHTMLTemplate(params *htmlParameters) (string, error) {
	var html bytes.Buffer

	t, err := template.New("html").Parse(HtmlTemplate)
	if err != nil {
		return "", err
	}

	if err := t.Execute(&html, params); err != nil {
		return "", err
	}

	return html.String(), nil
}
